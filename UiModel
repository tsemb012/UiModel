//UiModel 

class MyViewModel : ViewModel() {
    private val _textState = MutableLiveData<TextState>(TextState.Loading)//１つのLiveDataに統合
    val textState: LiveData<TextState> = _textState
    private val _listItems = MutableLiveData<List<String>>(listOf())//空のリストを初期値として入れる。
    val listItems = LiveData<List<String>> = _listItems
    ...
}

sealed class TextState{//LiveDataに状態を持たせる
    data class Loaded(val text: String): TextState//データと状態を同時に持っている。
    object Loading: TextState //objectは単一インスタンスのみもつクラスを作るキーワード
}
//増えていくLiveDataをSealedクラスを用いて管理


class MyFragment: Fragment(){
    override fun onViewCreated(view: View, savedInstanceState: Bundle?){
        super.onViewCreated(view, savedInstanceState)
        myViewModel.TextState.observe(viewLifeCycleOwner){textState ->
            textView.text = when(textState){
                is TextState.Loading -> "loading"
                is TextState.Loaded -> textState.text//Loadedのデータクラスに入っているデータも直接引っ張れる。
                //sealed classなのでelseを書く必要がない。
            }
        }
                /*
        これが不要になりました。
        myViewModel.isLoading.observe(viewLifecycleOwner) {
        }
        */
    }
    ...
}
//ここにどんどんobject LoadError: TextState等を追加すれば、LiveDataが１つで状態を増やしていくことができる。


data class MyUiModel(//MyViewModel内のLiveDataをまとめるMyUiModelクラスを定義する。
    val textState: TextState = TextState.Loading,
    val listItems: List<String> = listOf()//LiveDataクラスじゃない？
){
    companion object {
        operator fun invoke(//() だけでメソッドを呼び出だすことができる。
            current: MyUiModel,//instance()はコンパイラにはinstance.invoke()と解釈されます。
            textState: TextState,
            listItems: List<String>
        )= MyUiModel(
            textState = textState,
            listItems = listItems
        )
    }
}